# IoCommander v1.0.0
### Приложение для отправки команд удаленным клиентам через socket.io. Функционал написан на серверном javascript и представлен тремя отдельными частями

#### Скрипт сервера (настройки в файле "src-server\iocommander-server.conf", запуск "node .\src-server\iocommander-server.js"), который 

- Поднимает два сервера:  
  - web-сервер (веб-приложение панели управления, написанное на react + redux + socket.io)
  - socket-сервер (основной сервер приложения)
    
- Имеет два хранилища redux:
  - хранилище соединений (временное)
```
	{	
		users:{
			user1:uid1,
			user2:uid2
		},
		uids:{
			uid1:user1,
			uid2:user2
		}
	
	}
```
  - хранилище данных (постоянное, синхронизируется с firebase):
```
	{	
		users:{
			user1:password1,
			user2:password2
		},
		admins:{
			admin1:password1,
			admin2:password2
		},
		tasks:{
			user1:{
				uid1_task:{},
				uid2_task:{}
			},
			user2:{
				uid1_task:{},
				uid2_task:{}
			}
		}
	}
```

- Имеет хранилище firebase:
  Служит только для синхронизации. При изменении данных в постоянном хранилище - они будут записаны в firebase с отсрочкой в 1 минуту *(см.описание).
  Если база пуста, создаю учетку администратора с именем пользователя administrator, пароль 12345678
  Настройки безопасности, что-то вроде:
```
	{
	  "rules": {
		".read": "(auth.email == 'admin@sergdudko.tk')",
		".write": "(auth.email == 'admin@sergdudko.tk')"
	  }
	}
```

- При подключении к сокету, проверяет данные авторизации. Исходя из этого анализирует принадлежность клиента к администратору или пользователю (или вообще ни к тому, ни к другому). Если клиент - пользователь, может отправлять задания и слушать сокет (отчет о выполнении).
  Если клиент - администратор, слушает сокет на факт создания заданий. Отправляет в сокет соответствующее хранилище redux при изменении в хранилище.
  
- Имеет сборщик мусора, который удаляет выполненные задачи по сроку давности (установил в 10 дней), либо по отсутствующему пользователю. Запускается раз в час.
  

#### Скрипт клиента (настройки в файле "src-user\iocommander-usr.conf", запуск "node .\src-user\iocommander-usr.js"), который:

- Соединяется с сокетом-сервера и авторизуется в нем.
  
- Слушает сокет сервера на наличие заданий.

- При старте сервера загружает данные из локального хранилища src-user\storage.db.

- При поступлении задания пишет его в собственное хранилище redux:
```
	{
		tasks: {
			uid1_task:{},
			uid2_task:{}
		}, 
		complete: [
			uid1_task,
			uid2_task
		], 
		incomplete:[]
	}
```

- При каждом изменении в хранилище redux данные пишутся в src-user\storage.db (по сути json-файл) с отсрочкой в 15 секунд *(см.описание).
  
- Раз в 15 секунд проверяет невыполненные задания и пытается их выполнить.

- При разрыве соединения автоматически восстанавливает его.

- При неудачном выполнении задачи, пытается 100 раз её выполнить, после чего передаст текст ошибки серверу и установит ей статус выполнено.

- Имеет собственный сборщик мусора, для уничтожения устаревших заданий и ошибок синхронизации во внутренней базе данных. Срок хранения задач установил в 10 дней. Запускается раз в час.

- Анализирует тип операционной системы при выполнении заданий.

- Задание "скачать файл в папку", пример:
```
	{
		uid:'f0b11bc4-83d2-45aa-ba4d-b3fc86198cbf', 
		task: {
			nameTask:'getFileFromWWW', 
			extLink:'http://vpn.sergdudko.tk/releases/dwpanel-2.2.0-1.noarch.rpm', 	//ссылка для скачки
			intLink:'/test/', 														//каталог для записи (для win32 будет записан относительно диска C)
			fileName: '1.rpm', 														//имя файла, может отличатся от исходного
			exec:'false', 
			complete:'false',														//флаг, что задание выполнено
			answer:'', 																//вывод содержимого консоли по факту выполнения команды (обратная связь)
			dependencies:[], 														//зависимости, выполнение команды возможно, только если зависимости выполнены.
			platform:'all',															//тип операционной системы (all, win32 или linux)
			comment:'Тестовое задание',												//комментарий для вывода в отчеты
			datetime:1521528701303,													//время создания задачи	(epoch)
			datetimecompl:1521528701303,											//время получения отчета о выполнении/невыполнении задачи сервером	(epoch)
			timeoncompl:1521528701303,												//время после которого нужно выполнить задачу	(epoch)
			"tryval": 0																//попытка, с которой выполняется задание
		}
	}
```  

- Задание "Запустить локальный скрипт", пример:
```
	{
		uid:'f0b11bc4-83d2-45aa-ba4d-b3fc86198cbf', 
		task: {
			nameTask:'execFile', 
			intLink:'', 															//папка с скриптом
			fileName: 'node', 														//имя файла
			paramArray:['--version'], 												//параметры запуска
			complete:'false', 
			answer:'', 
			dependencies:['efc0a00f-00b3-489d-be28-b1760be01618'],
			platform:'linux',
			comment:'Тестовое задание',												
			datetime:1521528701303,												
			datetimecompl:1521528701303,									
			timeoncompl:1521528701303,												
			"tryval": 0																
		}
	}
```  

- Задание "Выполнить команду", пример:
```
	{
		uid:'f0b11bc4-83d2-45aa-ba4d-b3fc86198cbf', 
		task: {
			nameTask:'execCommand', 
			execCommand:'echo 111', 												//команда для выполнения
			platform:'win32', 														//тип операционной системы задан жестко, т.е. только win32 или linux
			dependencies:[
				'efc0a00f-00b3-489d-be28-b1760be01618', 
				'f0b11bc4-83d2-45aa-ba4d-b3fc86198cbf'
			],
			comment:'Тестовое задание',												
			datetime:1521528701303,												
			datetimecompl:1521528701303,									
			timeoncompl:1521528701303,												
			"tryval": 0
		}
	}
```  
  
* Снимок данных делается с отсрочкой, при этом на время отсрочки повторный запуск синхронизации блокируется. По факту получения снимка данных - он будет записан во внешнее хранилище. При ошибке, синхронизация запускается с начальным таймаутом, при этом блокировка повторного запуска не сбрасывается. При успешной записи сбрасывается блокировка и функция может быть запущена повторно.
Это позволяет с одной стороны не писать данные в базу без необходимости (только по факту изменений), с другой не писать данные чаще, чем установленный таймаут.

#### Веб-панель администратора

- Умеет авторизовавыться в сокете
  
- Автоматически получает измененные данные из сокета (два аналогичных серверу хранилища)

- Имеет собственное redux хранилище для функционирования админки и отчетов, регенерация отчетов в данном хранилище происходит по факту изменений в постоянном хранилище сервера.

- Реализовано на react framework

- Отображает онлайн пользователей

- Позволяет удалять/добавлять администраторов и пользователей

- Позволяет создавать задачи и передавать их серверу

- Генерирует отчеты по выполнению задач клиентами
